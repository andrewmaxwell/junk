{"version":3,"sources":["~lib/rt/common.ts","assembly/index.ts"],"names":[],"mappings":"qICKiB,EAAO,EAAX,CAAsB,EAA1B,CAAP,SAKmB,E,CAAS,SAAM,SAAN,CAAT,CAAnB,EACmB,E,CAAU,SAAM,SAAN,CAAV,CAAnB,EACc,SAAW,EAAI,EAAJ,C,EAAW,EAAI,EAAJ,C,OAAf,C,CAAP,CAAd,EACmB,EAAa,EAAb,CAAnB,EACiB,SAAM,E,CAAN,CAAjB,EAE0B,E,EAAG,E,OAAP,CAAtB,EAEkB,EAAb,E,EAAgB,EAAI,EAAJ,C,EACA,E,CAAI,EAAJ,CAAkB,EAAnB,CAAlB,EACiB,EAAI,EAAJ,CAAc,EAAf,CAAhB,EAEkB,EAAb,E,IAAgB,EAAI,EAAJ,C,EACN,E,CAAI,EAAJ,CAAY,EAAZ,CAAb,EAGS,S,EACF,S,EAGc,EAArB,EACA,E,EAAe,EAAK,EAAL,CAAP,EAA0B,EAAK,EAAL,CAAP,EAApB,CAAuC,SAAvC,C,EACA,SAAM,EAAN,CAAW,EAAX,CAAgB,EAAhB,CAAL,EACK,EAAO,EAAP,CAAc,EAAd,CAAL,EACI,EAAa,EAAb,CAAJ,EAAwB,GACtB,E,GAAF,E,KAIF,E,EAAO,EAAY,EAAZ,C,EACS,EAAK,EAAL,CAAU,EAAK,EAAL,CAAV,CAAoB,EAApB,CAAd,EACK,SAAM,EAAN,CAAW,EAAX,CAAgB,EAAhB,CAAL,EACK,EAAL,EACE,E,GAAF,E,KAMe,EAAa,EAAb,CAAjB,EACmB,EAAK,EAAL,CAAU,EAAK,EAAL,CAAV,CAAnB,EACI,EAAa,SAAb,CAAJ,EAC6B,SAAe,EAAT,EAAN,CAAV,EAAjB,EAEI,EAAa,EAAb,C,CACO,EAAY,EAAZ,C,CAAgB,EAAhB,CAA4B,EAA7B,CAAuC,SAAK,SAAlD,E,CAFS,EAAb,GAKS,EAAW,EAAK,EAAL,CAAX,CAAoB,EAA/B,GApCgC,E,GAAF,E,KAJC,E,GAAF,E","sourceRoot":"./debug","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","/** Number of discrete color values on the JS side. */\nconst NUM_COLORS = 2048;\n\n/** Clamps a value between the given minimum and maximum. */\nfunction clamp(value: number, minValue: number, maxValue: number): number {\n  return min(max(value, minValue), maxValue);\n}\n\n/** Updates the rectangle `width` x `height`. */\nexport function update(width: u32, height: u32, limit: u32): void {\n  const translateX = width * (1.0 / 1.6);\n  const translateY = height * (1.0 / 2.0);\n  const scale = 10.0 / min(3 * width, 4 * height);\n  const realOffset = translateX * scale;\n  const invLimit = 1.0 / limit;\n\n  const minIterations = min(8, limit);\n\n  for (let y: u32 = 0; y < height; ++y) {\n    const imaginary = (y - translateY) * scale;\n    const yOffset = (y * width) << 1;\n\n    for (let x: u32 = 0; x < width; ++x) {\n      const real = x * scale - realOffset;\n\n      // Iterate until either the escape radius or iteration limit is exceeded\n      let ix = 0.0,\n        iy = 0.0,\n        ixSq: f64,\n        iySq: f64;\n      let iteration: u32 = 0;\n      while ((ixSq = ix * ix) + (iySq = iy * iy) <= 4.0) {\n        iy = 2.0 * ix * iy + imaginary;\n        ix = ixSq - iySq + real;\n        if (iteration >= limit) break;\n        ++iteration;\n      }\n\n      // Do a few extra iterations for quick escapes to reduce error margin\n      while (iteration < minIterations) {\n        const ixNew = ix * ix - iy * iy + real;\n        iy = 2.0 * ix * iy + imaginary;\n        ix = ixNew;\n        ++iteration;\n      }\n\n      // Iteration count is a discrete value in the range [0, limit] here, but we'd like it to be\n      // normalized in the range [0, 2047] so it maps to the gradient computed in JS.\n      // see also: http://linas.org/art-gallery/escape/escape.html\n      let colorIndex = NUM_COLORS - 1;\n      const distanceSq = ix * ix + iy * iy;\n      if (distanceSq > 1.0) {\n        const fraction = Math.log2(0.5 * Math.log(distanceSq));\n        colorIndex = <u32>(\n          ((NUM_COLORS - 1) *\n            clamp((iteration + 1 - fraction) * invLimit, 0.0, 1.0))\n        );\n      }\n      store<u16>(yOffset + (x << 1), colorIndex);\n    }\n  }\n}\n"]}