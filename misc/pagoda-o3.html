<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Voxel Pagoda Garden with Structure</title>
  <style>
    html,body { margin:0; height:100%; overflow:hidden; background:#dfeffa }
    canvas     { display:block; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/controls/OrbitControls": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js",
      "three/postprocessing/EffectComposer": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js",
      "three/postprocessing/RenderPass": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js",
      "three/postprocessing/UnrealBloomPass": "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js"
    }
  }
  </script>
</head>
<body>
<canvas id="c"></canvas>
<script type="module">
import * as THREE          from 'three';
import { OrbitControls }   from 'three/controls/OrbitControls';
import { EffectComposer }  from 'three/postprocessing/EffectComposer';
import { RenderPass }      from 'three/postprocessing/RenderPass';
import { UnrealBloomPass } from 'three/postprocessing/UnrealBloomPass';

//
// Renderer
//
const canvas   = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled   = true;
renderer.shadowMap.type      = THREE.PCFSoftShadowMap;
renderer.toneMapping         = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
renderer.outputColorSpace    = THREE.SRGBColorSpace;

//
// Scene, Camera, Controls
//
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xdfeffa);
scene.fog        = new THREE.Fog(0xdfeffa, 80, 200);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 500);
camera.position.set(50, 35, 50);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.target.set(0, 6, 0);

//
// Lights
//
scene.add(new THREE.HemisphereLight(0xedf7ff, 0x556b2f, 0.6));

const sun = new THREE.DirectionalLight(0xfff2e0, 1.25);
sun.position.set(45, 60, 30);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.bias = -0.0002;
sun.shadow.camera = new THREE.OrthographicCamera(-80, 80, 80, -80, 0.5, 200);
scene.add(sun);

const accent = new THREE.PointLight(0xfff5e1, 0.4, 100);
accent.position.set(0, 25, 0);
scene.add(accent);

//
// Postprocessing
//
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
composer.addPass(new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight), 0.42, 0.4, 0.9));

//
// Voxel Helpers
//
const VOX = 1;
const geoCache = {};
function voxelMesh(hex) {
  if (!geoCache[hex]) geoCache[hex] = new THREE.BoxGeometry(VOX, VOX, VOX);
  const mat = new THREE.MeshStandardMaterial({ color: hex });
  const m   = new THREE.Mesh(geoCache[hex], mat);
  m.castShadow = m.receiveShadow = true;
  return m;
}
function put(x, y, z, hex){
  const m = voxelMesh(hex);
  m.position.set(x*VOX, y*VOX, z*VOX);
  scene.add(m);
}

// Ground
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(300, 300),
  new THREE.MeshStandardMaterial({ color: 0x5a9c4e })
);
ground.rotation.x    = -Math.PI/2;
// sink it a hair so your y=0 beams and floor sit flush
ground.position.y    = -0.01;
ground.receiveShadow = true;
scene.add(ground);

//
// Pagoda with real floors & railings
//
function buildPagoda(cx, cz, tiers = 5) {
  let half = 9, y = 1;
  const floorClr = 0x6d4c41;  // wood deck
  const beamClr  = 0x3e2723;  // dark support beams
  const railClr  = 0xffd54f;  // railing

  for (let t = 0; t < tiers; t++) {
    // --- Deck ---
    for (let x = -half; x <= half; x++) {
      for (let z = -half; z <= half; z++) {
        put(cx + x, y,   cz + z, floorClr);
      }
    }

    // --- Under‐deck support beams (sit at y−1, so they rest on the ground) ---
    for (let x = -half; x <= half; x++) {
      put(cx + x, y - 1, cz - half, beamClr);
      put(cx + x, y - 1, cz + half, beamClr);
    }
    for (let z = -half; z <= half; z++) {
      put(cx - half, y - 1, cz + z, beamClr);
      put(cx + half, y - 1, cz + z, beamClr);
    }

    // --- Walls ---
    for(let x=-half; x<=half; x++){
      for(let z=-half; z<=half; z++){
        if(Math.abs(x)===half || Math.abs(z)===half){
          put(cx+x, y+1, cz+z, 0xd32f2f);
          if((x+z)%2===0) put(cx+x, y+2, cz+z, 0xd32f2f);
        }
      }
    }

    // --- Railings around edge ---
    for(let x=-half+1; x<half; x++){
      put(cx+x, y+3, cz-half, railClr);
      put(cx+x, y+3, cz+half, railClr);
    }
    for(let z=-half+1; z<half; z++){
      put(cx-half, y+3, cz+z, railClr);
      put(cx+half, y+3, cz+z, railClr);
    }

    // --- Roof Eaves ---
    const roof = 0x1f3144;
    for(let x=-half-1; x<=half+1; x++){
      for(let z=-half-1; z<=half+1; z++){
        if(Math.abs(x)===half+1 || Math.abs(z)===half+1){
          put(cx+x, y+4, cz+z, roof);
        }
      }
    }

    // --- Corner Columns full height ---
    const col = 0x45241c;
    [-half, half].forEach(ix=>{
      [-half, half].forEach(iz=>{
        for(let py=y+1; py<=y+4; py++){
          put(cx+ix, py, cz+iz, col);
        }
      });
    });

    // prepare next tier
    y += 5;      // floor + 4 levels of walls/eaves
    half -= 2;
    if(half < 2) break;
  }
}
buildPagoda(0, 0, 5);

//
// Pond & Lilypads
//
const pond = new THREE.Mesh(
  new THREE.BoxGeometry(12, 0.5, 12),
  new THREE.MeshPhysicalMaterial({ color:0x2680d6, roughness:0.1, metalness:0.2, clearcoat:0.5 })
);
pond.position.set(0, 0, 14);  // bottom of the 0.5-high block is right on the ground
pond.receiveShadow = true;
scene.add(pond);


for(let i=0;i<9;i++){
  const a = Math.random()*Math.PI*2, r = 5 + Math.random()*4;
  const lx = Math.round(Math.cos(a)*r), lz = Math.round(Math.sin(a)*r);
  put(lx, 1, 14 + lz, 0x3ea047);
}
pond.rotation.y = 0.15;

//
// Path & Lanterns
//
for(let p=-12; p<=12; p++){
  if(p<-3 || p>3) put(p,1,-12,0x9e9e9e);
}
function lantern(x,z){
  put(x,2,z,0xffd54f);
  const L = new THREE.PointLight(0xffd54f,1.2,12);
  L.position.set(x,3.5,z);
  L.castShadow = true;
  scene.add(L);
}
lantern(-4,-12);
lantern( 4,-12);

//
// Trees & Flowers
//
function growTree(tx,tz,h,hex){
  for(let yy=1; yy<=h; yy++) put(tx,yy,tz,0x6d4c41);
  for(let dx=-2; dx<=2; dx++)
  for(let dz=-2; dz<=2; dz++)
  for(let dy=0; dy<=2; dy++){
    if(Math.abs(dx)+Math.abs(dz)+dy<4) put(tx+dx, h+dy, tz+dz, hex);
  }
}
for(let i=0;i<18;i++){
  const a = Math.random()*Math.PI*2, r = 20 + Math.random()*18;
  growTree(Math.round(Math.cos(a)*r), Math.round(Math.sin(a)*r), 5+~~(Math.random()*3), 0x2e7d32);
}
for(let i=0;i<12;i++){
  const a = Math.random()*Math.PI*2, r = 12 + Math.random()*18;
  growTree(Math.round(Math.cos(a)*r), Math.round(Math.sin(a)*r), 4+~~(Math.random()*2), 0xffc1e3);
}


      // --- Flowers around the garden ---
    const fcols = [0xff80ab, 0xffb74d, 0xba68c8];
    for (let i = 0; i < 50; i++) {
      const x = Math.round(Math.random() * 160 - 80),
            z = Math.round(Math.random() * 160 - 80);
      if (x * x + z * z < 60) continue;  // keep central area clear
      put(x, 1, z, fcols[i % fcols.length]);
    }

    //
    // Resize handler & render loop
    //
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
    });

    (function animate() {
      controls.update();
      composer.render();
      requestAnimationFrame(animate);
    })();
  </script>
</body>
</html>
